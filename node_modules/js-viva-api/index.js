
var querystring = require('querystring');
// var request = require('browser-request');
// var request = function() {};

// Constant Values

var PORTALS = [
  'VR_BR', 'VR_MX', 'VR_CO', 'VR_NET', 'VR_US'
];

var PROPERTY_TYPES = {

};

var BUSINESS_TYPES = {
  'SALE': 'VENTA',
  'RENT': 'RENTA'
};

var ORDER_TYPES = {
  "PRICE_ASCENDING": "precio_venta_base",
  "PRICE_DESCENDING": "precio_venta_base desc",
  "BATHROOMS": "banos",
  "BEDROOMS": "habitaciones"
};

var CURRENCY_DEFAULTS = {
  'VR_BR': 'BRL',
  'VR_CO': 'COP',
  'VR_MX': 'MXN',
  'VR_US': 'USD',
  'VR_NET': 'USD'
};

var LEVEL_CONVERSIONS = {
  "COUNTRY": 1,
  "STATE": 2,
  "CITY": 4,
  "ZONE": 5,
  "NEIGHBORHOOD": 6,
  "LISTINGS": null
};

// Utilities brought in from underscore

function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function each(obj, iterator, context) {
  if (!obj) return;
  if (obj.length === +obj.length) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (iterator.call(context, obj[i], i, obj) === {}) return;
    }
  } else {
    for (var key in obj) {
      if (has(obj, key)) {
        if (iterator.call(context, obj[key], key, obj) === {}) return;
      }
    }
  }
}

function extend(obj) {
  each(Array.prototype.slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

function getQueryString(parameters) {
  // the querystring module in the browser is failing to add non-string parameters :(
  // so let's convert them all first.
  var stringParams = {};

  each(parameters, function(val, key) {
    stringParams[key] = val.toString();
  });

  return querystring.stringify(stringParams);
}

function fetchJSON(targetUrl, callback) {
  if ($ && $.ajax) {
    $.get(targetUrl, function(data) {
      callback(null, data);
    })
    .fail(callback);
  }
  // request(targetUrl, function(err, res, body) {
  //   if (err) { 
  //     callback(err); 
  //   }
  //   var json = JSON.parse(body);
  //   callback(null, json);
  // });
}

function getQueryParametersFromCore(core) {
  return {
    apiKey: core.apiKey,
    portal: core.portal
  };
}

function processRangeFilter(parameters, startKey, stopKey) {
  var out = {};
  if (parameters && parameters.length && parameters.length === 2) {
    if (parameters[0]) {
      out[startKey] = parameters[0];
    }
    if (parameters[1]) {
      out[stopKey] = parameters[1] || null;
    }
  }
  return out;
}

// Convert the filter object into the parameters needed by the API
function processFilters(filters) {
  var out = {};

  // Add the parsed range filters
  extend(out, processRangeFilter(filters.area,      'areaFrom', 'areaUpTo'));
  extend(out, processRangeFilter(filters.bedrooms,  'roomsFrom', 'roomsUpTo'));
  extend(out, processRangeFilter(filters.bathrooms, 'bathroomsFrom', 'bathroomsUpTo'));
  extend(out, processRangeFilter(filters.price,     'initialBasePrice', 'finalBasePrice'));
  extend(out, processRangeFilter(filters.parking,   'garagesFrom', 'garagesUpTo'));

  // Add the parameters that need to be parsed from strings
  if (ORDER_TYPES[filters.order]) {
    out.order = ORDER_TYPES[filters.order];
  }

  if (PROPERTY_TYPES[filters.type]) {
    out.listingType = PROPERTY_TYPES[filters.type];
  }

  if (filters.numResults) {
    out.maxResults = filters.numResults;
  }

  if (has(filters, 'hasPhoto')) {
    out.hasImage = filters.hasPhoto;
  }

  // Parameters with defaults
  out.page = filters.page || 1;

  return out;
}

function parseLocations(locations) {

  function getZone(lokation) {
    return lokation.split('/').slice(0,4).join('/');
  }

  function areSameZone(locations) {
    var result = true;
    var firstZone = getZone(locations[0]);
    each(locations, function(lokation) {
      result = result && getZone(lokation) === firstZone;
    });
    return result;
  }

  function getNeighborhoods(locations) {
    var results = [];
    each(locations, function(lokation) {
      results.push(lokation.split('/').slice(4));
    });
    return results.join(',');
  }

  if (Object.prototype.toString.call(locations) === "[object String]") {
    return { url: locations };
  } else {
    if (areSameZone(locations)) {
      return {
        url: getZone(locations[0]),
        parameters: {
          neighborhood: getNeighborhoods(locations)
        }
      };
    } else {
      throw "Listings Error: All locations must be from the same zone.";
    }
  }
}

function processListingsParameters(parameters) {
  if (BUSINESS_TYPES[parameters.business]) {
    return {
      business: BUSINESS_TYPES[parameters.business]
    };
  }
  return {};
}

function listings(core, parameters, filters) {
  // Parse the locations values into a url fragment
  var locations = parseLocations(parameters.locations);

  var queryParameters = extend(

    // Get the parameters that need to go in the query string from the core parameters
    getQueryParametersFromCore(core), 

    // Add any addiitonal parameters needed for location
    locations.parameters || {},

    // Get the parameters that need to go in the query string from the listings parameters
    processListingsParameters(parameters),

    // Parse the extra filters into their query string representation
    processFilters(filters)
  );

  return core.baseUrl + '/locations' + locations.url + '/listings' + '?' + getQueryString(queryParameters);
}

function processGeoSearchParameters(parameters) {
  return {
    lat: parameters.latitude,
    'long': parameters.longitude,
    r: parameters.radius
  };
}

function geoSearch(core, parameters, filters) {
  var level = LEVEL_CONVERSIONS[parameters.level];
  var pathName = '/listings';

  // If we have a level parameter we need a different path
  if (level) {
    pathName = '/listings/clusters/' + level + '/locations';
  }

  var queryParameters = extend(
      
    // Provide a default value for maxResults since it's required by the geoListings API
    { maxResults: 250 },

    // Get the parameters that need to go in the query string from the core parameters
    getQueryParametersFromCore(core), 

    // Get the parameters that need to go in the query string from the listings parameters
    processGeoSearchParameters(parameters),

    // Parse the extra filters into their query string representation
    processFilters(filters)
  );

  // parse the given values into a url
  return core.baseUrl + pathName + '?' + getQueryString(queryParameters);
}

function autocomplete(core, phrase) {

  var queryParameters = extend(
      
    // Get the parameters that need to go in the query string from the core parameters
    getQueryParametersFromCore(core), 

    { input: encodeURI(phrase.replace(/^\s+|\s+$/g, '').replace(/\s/g, '+')) }
  );

  // parse the given values into a url
  return core.baseUrl + '/locations/autocomplete' + '?' + getQueryString(queryParameters);
}

function getProperty(core, propertyID) {
  var pathName = '/listings/' + propertyID;

  // Get the parameters that need to go in the query string from the core parameters
  var queryParameters = getQueryParametersFromCore(core);

  return core.baseUrl + pathName + '?' + getQueryString(queryParameters);
}

var VivaApi = function(options) {
  
  // test for required options
  var required = [ 'baseUrl', 'apiKey', 'portal' ];
  for (var i = 0; i < required.length; i++) {
    if (!options[required[i]] || typeof options[required[i]] !== "string") {
      throw "Error initializing API: No " + required[i];
    }
  }
  
  // test to make sure the portal is valid
  if (!~PORTALS.indexOf(options.portal)) {
    throw "Error initializing API: Invalid portal";
  }

  // test for a token stringy-ness
  if (options.token && typeof options.token !== "string") {
    throw "Error initializing API: token is not a string";
  }

  // initialize values
  this.core = {
    baseUrl: options.baseUrl,
    apiKey: options.apiKey,
    portal: options.portal
  };

  if (options.token) {
    this.core.token = options.token;
  }

};

VivaApi.prototype.listings = function(parameters, filters, callback) {
  if (!filters) {
    filters = {};
  }

  if (typeof filters === 'function') {
    callback = filters;
    filters = {};
  }

  var hasCallback = callback && typeof callback === 'function';
  var url; 

  // Test to make sure parameters is defined and has a locations field
  if (!parameters || !parameters.locations || !BUSINESS_TYPES[parameters.business]) {
    throw "Listings Error: A location and a valid business parameter is required";
  }

  try {
    url = listings(this.core, parameters, filters);
  } catch (error) {
    if (hasCallback) {
      callback(error);
    } else {
      throw error;
    }
  }

  if (hasCallback) {
    // fetch url and pass on values
    fetchJSON(url, callback);
  } else {
    return url;
  }
};

VivaApi.prototype.geoSearch = function(parameters, filters, callback) {
  if (!filters) {
    filters = {};
  }

  if (typeof filters === 'function') {
    callback = filters;
    filters = {};
  }

  var hasCallback = callback && typeof callback === 'function';
  var url; 

  // Test to make sure parameters is defined and has a locations field
  if (!parameters || !parameters.radius || !parameters.latitude || !parameters.longitude || !parameters.level) {
    throw "GeoSearch Error: Latitude, Longitude, Radius, and Level required.";
  }

  if (!has(LEVEL_CONVERSIONS, parameters.level)) {
    throw 'GeoListings Error: Level must be one of: "COUNTRY", "STATE", "CITY", "ZONE", "NEIGHBORHOOD", "LISTINGS".';
  }

  try {
    url = geoSearch(this.core, parameters, filters);
  } catch (error) {
    if (hasCallback) {
      callback(error);
    } else {
      throw error;
    }
  }

  if (hasCallback) {
    // fetch url and pass on values
    fetchJSON(url, callback);
  } else {
    return url;
  }
};

VivaApi.prototype.autocomplete = function(phrase, callback) {
  var hasCallback = callback && typeof callback === 'function';
  var url; 

  // Test to make sure parameters is defined and has a locations field
  if (!phrase) {
    throw "Autocomplete Error: Must pass text to complete.";
  }

  try {
    url = autocomplete(this.core, phrase);
  } catch (error) {
    if (hasCallback) {
      callback(error);
    } else {
      throw error;
    }
  }

  if (hasCallback) {
    // fetch url and pass on values
    fetchJSON(url, callback);
  } else {
    return url;
  }
};

VivaApi.prototype.property = function(propertyID, callback) {
  var hasCallback = callback && typeof callback === 'function';
  var url; 

  // Test to make sure parameters is defined and has a locations field
  if (!propertyID) {
    throw "Autocomplete Error: Must pass text to complete.";
  }

  try {
    url = getProperty(this.core, propertyID);
  } catch (error) {
    if (hasCallback) {
      callback(error);
    } else {
      throw error;
    }
  }

  if (hasCallback) {
    // fetch url and pass on values
    fetchJSON(url, callback);
  } else {
    return url;
  }
};

/*
VivaApi.prototype.contact = function(propertyID, callback) {};

VivaApi.prototype.sendLead = function(leadData, callback) {};
*/



module.exports = VivaApi;
